# Функция Эйлера
Значение функции Эйлера `f(n)` для любого `n` --- это количество чисел на промежутке `[1; n]`, являющихся взаимно простыми с `n`.
__[Первые 69 значений функции Эйлера](http://oeis.org/A000010)__

## Свойства
1. Логично, что если `n` простое, то `f(n) = n-1`, так как нам не подходит только само число `n`.
2. `f(p^a) = p^a - p^(a-1)`
Если взять любое `p` и `a`, то можно заметить, что нам не подходит только `p` чисел.
Например, если `p = 3, a = 3`, на промежутке `[1; 27]` нам не подходят числа `3, 6, 9, 12, 15, 18, 21, 24, 27`, то есть, числа вида `p*k`, где `k` -- натуральное число. Таких чисел всегда `(p^a) / p = p ^ (a-1)`.
3. `f(a*b) = f(a) * f(b)` ([китайская теорема об остатках](http://e-maxx.ru/algo/chinese_theorem "Потом обязательно разберу"))

## Суть
1. Пусть дано число `n`, необходимо вычислить его `f(n)`. Разобьем число на простые множители:
`n = p[1]^a[1] * p[2]^a[2] * p[3]^a[3] * ... * p[k]^a[k]`, где любое `p[i]` - простое число.
2. Применим третье свойство:
`f(n) = f(p[1]^a[1]) * f(p[2]^a[2]) * f(p[3]^a[3]) * ... * f(p[k]^a[k])`
3. Применим второе свойство:
`f(n) = (p[1]^a[1] - p[1]^(a[1]-1)) * (p[2]^a[2] - p[2]^(a[2]-1)) * (p[3]^a[3] - p[3]^(a[3]-1)) * ... * (p[k]^a[k] - p[k]^(a[k]-1))`
4. Рассмотрим выражение `p[k]^a[k] - p[k]^(a[k]-1)`:
`p[k]^a[k] - p[k]^(a[k]-1) = p[k]^(a[k]-1) * (p[k] - 1) = p[k]^a[k] * (p[k] - 1)/p[k] = p[k]^a[k] * (p[k]/p[k] - 1/p[k]) = p[k]^a[k] * (1 - 1/p[k])`
Мы можем "собрать" из каждого множителя этот `p[k]^a[k]` и сжать его в `n` (как в пункте _1_).
5. Получаем:
`f(n) = n * (1 - 1/p[1]) * (1 - 1/p[2]) * (1 - 1/p[3]) * ... * (1 - 1/p[k])`
Это и есть теорема Эйлера.
Реализация сводится к разложению на простые множители.

## Свойства, p.2
- Если числа `a` и `m` взаимно просты (то есть, `gcd(a, m) == 1`), работает самое важное свойство функции Эйлера:
`a^f(m) mod m == 1`
- В частности, если `m` также является простым числом, благодаря первому свойству можем представить `f(m)` как `m-1`:
`a^(m-1) mod m == 1`

## Задачи
- [Дано число. Найти значение его функции Эйлера](https://acmp.ru/asp/do/index.asp?main=task&id_course=2&id_section=18&id_topic=43&id_problem=294)

## Детали реализации
Рассмотрим выражение `n * (1 - 1/p[1])`. Его вычисление может быть выполнено с погрешностями, у меня это привело к WA14 на acmp. Можно внести `n` в скобки. Получим выражение `n - n/p[1]`. Мы знаем, что `p[1]` является делителем `n`, поэтому здесь никаких погрешностей возникнуть не может. Соответственно, если мы посчитали уже какой-то ответ `ans`, и теперь хотим "добавить" `p[x]`, разумнее будет выполнить `ans = ans - ans/p[x]`, или `ans -= ans/p[x]`.

Также следует не забывать, что после нахождения простых множителей у `n` следует также выполнить `ans -= ans/n`, если `n` обновлялось при поиске.
