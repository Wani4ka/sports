# Решето Эратосфена
Решето Эратосфена используется для нахождения всех простых делителей на промежутке `[2; N]` (`N` задается). Предложенная здесь реализация потребляет `O(N)` памяти и [выполняет `O(N log log N)` операций](http://e-maxx.ru/algo/eratosthenes_sieve#2 "Доказательство с e-maxx, слишком сложное, чтобы расписать здесь :)").

## Идея
1. Выпишем в ряд все натуральные числа на промежутке `[2;N]`, пусть `N = 20`.
   >2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

2. Вычеркнем все числа, кратные `2`, кроме самой `2`.
   >2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 ~~10~~ 11 ~~12~~ 13 ~~14~~ 15 ~~16~~ 17 ~~18~~ 19 ~~20~~

3. Вычеркнем все числа, кратные `3`, кроме самой `3`.
   >2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ ~~10~~ 11 ~~12~~ 13 ~~14~~ ~~15~~ ~~16~~ 17 ~~18~~ 19 ~~20~~

4. Повторим операцию для `5`, `7`, `11` и так далее до `20`.

__Иными словами__, для каждого невычеркнутого `x` мы вычеркиваем все числа, большие `x`, меньшие `n` и кратные `x`.
В результате имеем:
>2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ ~~10~~ 11 ~~12~~ 13 ~~14~~ ~~15~~ ~~16~~ 17 ~~18~~ 19 ~~20~~

## Детали реализации
- Число `1` (как и `0`) не является ни простым, ни составным. В рамках нашей реализации они помечаются как составные и вообще не учитываются.
- Нет необходимости для каждого `x` начинать вычеркивать числа с `2x`. Здесь, опять же, появляется еще один простой множитель `2`, при котором это число уже было вычеркнуто. То же самое можно сказать для всех чисел на промежутке `(x; x^2)` - там все числа уже были "обработаны" предыдущими `x`. Поэтому, чтобы получить `O(N log log N)` операций, нужно начинать обрабатывать все кратные `x` числа, _начиная с `x^2`_.

## Оптимизации
- Можно бежать не до `N`, а до `sqrt(N)`. На [e-maxx](http://e-maxx.ru/algo/eratosthenes_sieve#4) доказывается, что асимптотика не изменится, но количество операций уменьшится (в `sqrt(N)` раз?)
- Количество операций можно уменьшить, зная, что все четные числа, кроме `2`, являются составными. На самом деле, аналогично можно сказать и про 3, и про 5, и про 7, но тогда может сильно раздуться объем кода :)
Мы же можем просто пропускать при вычислении решета все четные числа, начиная бежать в основном цикле с `3` и шагом `2`.
- Можно хранить не массив `bool`'ов, а массив целых чисел и проводить операции с битами. Так как один `bool` "весит" 1 байт, а в 4-байтовом `int` можно хранить 32 "нолика" или "единички", можно сократить количество используемой памяти в __8__ раз. При этом, из-за битовых вычислений сильно увеличится количество операций. Поэтому такую оптимизацию нужно использовать только если мы можем пожертвовать скоростью, но нам катастрофически не хватает памяти.
Более подробно о битовом сжатии можно почитать [здесь](http://acm.math.spbu.ru/~sk1/mm/lections/2014-08-20-bits.pdf).

Моя реализация использует первые две оптимизации.